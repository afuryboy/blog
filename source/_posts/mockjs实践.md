---
title: mockjs实践
tag: mockjs
---

# 使用背景
> 入职新公司不久， 这边的开发模式也是前后端分离，在后台接口没有开发完成的情况下，而前端工作已经做完了，等接口是不可能的，这边的解决方案是在前端用node再起一个server服务,只做接口和数据，没用任何业务代码。我是不太喜欢这种方式（原因参考弊端），所以在新项目中，我是力荐使用mockjs来代替这种造伪数据的方式。

# 弊端

> 这种方式带来的问题也是显而易见

- 1、数据层，要写大量的数据，即使copy,也是很恶心的，因为你的数据都是一样的，改起来就是一个体力活了。

- 2、项目的复杂性提高，前后端分离开发的方式就是保证前端的独立性，如今又要在前端起一个server服务（虽然不写什么业务代码），同时需要你了解node,写一些路由相关的代码（虽然这些很简单），这始终是跟前后端分离开发的模式相背离。

# 实际操作(贴代码)

- 假设你已经知道接口地址了，只是后端开没开发，没关系我们依旧正常的在前端引入ajax库，发请求。如图

![1](1.png)

- 这个时候你可能会问？mock呢？伪数据呢？继续往下看

![2](2.png)

!> 首先确保你在开发环境下用到mockjs,而生产环境切记不要引入mockjs,不然就爆炸了。


- 设置拦截规则（mockjs会匹配你的url,来拦截你的请求，并返回数据给你）
![3](3.png)

!> 需要注意的是最好的方式是匹配的规则里写上正则，如果直接写请求的url也行，但是在get请求方式的话不行，因为get请求会把params里的参数拼接到url,导致匹配不上。post的话，因为参数在请求的body中，所以没关系。

```js
  Mock.mock(规则，数据)
```

# 重点来了（怎么造数据）

![4](4.png)

```js
// 'accounts|20' 代表 accounts这个字段mock会给你造20条数据
// Random对象是一个方法集合。Random.string(5) 随机造一个长度为5的字符串给你 Random.email()造一个邮箱给你 Random.cname()造一个中文名给你 等等mockjs内部有很多这样的方法
// Random.extend这个方法是让你自定义一个占位符
Random.extend({
  status: function (data) {
    let status = [
      {
        code: 1,
        name: '正常'
      },
      {
        code: 0,
        name: '待开通'
      },
      {
        code: 2,
        name: '停用'
      }
    ]
    return this.pick(status)
  }
})

// 然后我就可以 'status': '@status'的方式，让mockjs随机从数组中放回一个数据给我
```

# 结果

![5](5.png)

![6](6.png)

![7](7.png)

# 参考资料
[mockjs文档](https://github.com/nuysoft/Mock/wiki)